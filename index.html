<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DNA Helix</title>
<style>
  html,body{height:100%;margin:0}
  body{
    background:#050714;
    overflow:hidden;
    display:grid;
    place-items:center;
  }
  /* background like your reference (dark, soft vignette) */
  .wrap{
    position:relative;
    width:min(92vmin,520px);
    aspect-ratio: 306 / 330;
    border-radius:18px;
    overflow:hidden;
    background:
      radial-gradient(120% 120% at 65% 15%, rgba(140,160,255,.22) 0%, rgba(20,24,60,.0) 55%),
      radial-gradient(120% 120% at 25% 85%, rgba(90,220,255,.10) 0%, rgba(20,24,60,.0) 60%),
      radial-gradient(140% 140% at 50% 50%, rgba(255,255,255,.06) 0%, rgba(0,0,0,0) 55%),
      linear-gradient(180deg,#0a0d22 0%, #050714 55%, #040512 100%);
    box-shadow: 0 30px 70px rgba(0,0,0,.55);
  }
  .wrap::after{
    content:"";
    position:absolute; inset:-30%;
    background: radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 35%, rgba(0,0,0,.55) 70%, rgba(0,0,0,.85) 100%);
    pointer-events:none;
  }

  canvas{
    position:absolute; inset:0;
    width:100%; height:100%;
  }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // --- tuned to match the reference ---
  const CFG = {
    r: 62,               // helix radius
    height: 240,         // visible helix height
    steps: 34,           // number of rungs
    pitch: 10.5,         // vertical spacing between rungs
    twist: 0.55,         // phase step per rung
    spinSpeed: 0.9,      // rotation speed
    travelSpeed: 36,     // upward travel px/sec (loops)
    perspective: 420,    // projection distance
    centerX: 0.5,
    centerY: 0.53,

    // colors (cyan + pink like the image)
    cyan:  { core: "rgba(90,235,255,1)", glow: "rgba(90,235,255,.18)" },
    pink:  { core: "rgba(255,110,195,1)", glow: "rgba(255,110,195,.18)" },

    lineCoreAlpha: 0.62,
    lineGlowAlpha: 0.22,
    dotCoreR: 2.0,
    dotGlowR: 10.5,
    glowBlur: 10,

    // subtle overall softness like the reference
    masterAlpha: 0.95
  };

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function resize() {
    const r = canvas.getBoundingClientRect();
    canvas.width  = Math.round(r.width * DPR);
    canvas.height = Math.round(r.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  function project(x, y, z) {
    // simple perspective projection
    const s = CFG.perspective / (CFG.perspective + z);
    return { x: x * s, y: y * s, s };
  }

  function drawGlowDot(px, py, colorCore, colorGlow, coreR, glowR, alpha) {
    // glow
    const g = ctx.createRadialGradient(px, py, 0, px, py, glowR);
    g.addColorStop(0.0, colorGlow.replace(/[\d.]+\)$/, `${0.55*alpha})`));
    g.addColorStop(0.35, colorGlow.replace(/[\d.]+\)$/, `${0.25*alpha})`));
    g.addColorStop(1.0, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(px, py, glowR, 0, Math.PI*2);
    ctx.fill();

    // core
    ctx.fillStyle = colorCore.replace(/[\d.]+\)$/, `${alpha})`);
    ctx.beginPath();
    ctx.arc(px, py, coreR, 0, Math.PI*2);
    ctx.fill();
  }

  function drawBridge(x1,y1,x2,y2, gradA, gradB, alphaCore, alphaGlow) {
    const grad = ctx.createLinearGradient(x1,y1,x2,y2);
    grad.addColorStop(0, gradA.replace(/[\d.]+\)$/, `${alphaCore})`));
    grad.addColorStop(0.5, "rgba(240,245,255,0.18)");
    grad.addColorStop(1, gradB.replace(/[\d.]+\)$/, `${alphaCore})`));

    // glow pass
    ctx.lineWidth = 2.6;
    ctx.strokeStyle = gradA.replace(/[\d.]+\)$/, `${alphaGlow})`);
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();

    // core pass
    ctx.lineWidth = 1.15;
    ctx.strokeStyle = grad;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
  }

  let last = performance.now();
  let t = 0;

  function frame(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    t += dt;

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0, 0, w, h);

    // additive glow like the reference
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = CFG.masterAlpha;
    ctx.lineCap = "round";

    // soft blur to mimic bloom
    ctx.filter = `blur(${CFG.glowBlur}px)`;

    const cx = w * CFG.centerX;
    const cy = h * CFG.centerY;

    // depth-sort by average z so crossing looks right
    const items = [];

    for (let i = 0; i < CFG.steps; i++) {
      // loop upward travel
      const y0 = (i * CFG.pitch - (t * CFG.travelSpeed)) % CFG.height;
      const y = y0 - CFG.height/2;

      const phase = i * CFG.twist + t * CFG.spinSpeed;

      // 3D helix (two strands are opposite)
      const xA =  CFG.r * Math.cos(phase);
      const zA =  160  * Math.sin(phase);

      const xB = -CFG.r * Math.cos(phase);
      const zB = -160  * Math.sin(phase);

      // projection
      const pA = project(xA, y, zA);
      const pB = project(xB, y, zB);

      // screen coords
      const Ax = cx + pA.x, Ay = cy + pA.y;
      const Bx = cx + pB.x, By = cy + pB.y;

      // depth-based alpha/size (near = brighter)
      const nearA = Math.max(0, Math.min(1, (zA + 160) / 320));
      const nearB = Math.max(0, Math.min(1, (zB + 160) / 320));

      const aA = 0.25 + nearA * 0.55;
      const aB = 0.25 + nearB * 0.55;

      items.push({
        z: (zA + zB) * 0.5,
        Ax,Ay,Bx,By,
        aA,aB,
        sA: pA.s, sB: pB.s
      });
    }

    items.sort((a,b)=>a.z-b.z);

    for (const it of items) {
      // bridges (glow + core)
      drawBridge(
        it.Ax, it.Ay, it.Bx, it.By,
        CFG.cyan.core, CFG.pink.core,
        CFG.lineCoreAlpha * 0.9,
        CFG.lineGlowAlpha * 0.9
      );
    }

    // dots (glow + core)
    for (const it of items) {
      const coreA = CFG.dotCoreR * (0.8 + it.sA*0.6);
      const coreB = CFG.dotCoreR * (0.8 + it.sB*0.6);
      const glowA = CFG.dotGlowR * (0.85 + it.sA*0.45);
      const glowB = CFG.dotGlowR * (0.85 + it.sB*0.45);

      drawGlowDot(it.Ax, it.Ay, CFG.cyan.core, CFG.cyan.glow, coreA, glowA, it.aA);
      drawGlowDot(it.Bx, it.By, CFG.pink.core, CFG.pink.glow, coreB, glowB, it.aB);
    }

    // sharpen slightly by drawing a crisp pass without blur (like small bright cores)
    ctx.filter = "none";
    ctx.globalCompositeOperation = "lighter";

    for (const it of items) {
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.beginPath(); ctx.arc(it.Ax, it.Ay, 1.0*(0.8+it.sA), 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(it.Bx, it.By, 1.0*(0.8+it.sB), 0, Math.PI*2); ctx.fill();
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>